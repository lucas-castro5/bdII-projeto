1. Índices (Performance de Busca)
Índices são vitais para acelerar consultas de leitura, embora tenham um pequeno custo na escrita.

SQL

-- A) INDICE SIMPLES
-- Cenário: Buscas frequentes pelo nome do usuário no sistema administrativo.
-- Antes do índice, o banco faria um "Seq Scan" (leitura sequencial) em toda a tabela.
CREATE INDEX idx_usuario_nome ON usuario(nome);

-- Demonstração de eficácia (Conceitual):
-- EXPLAIN ANALYZE SELECT * FROM usuario WHERE nome = 'João Silva';


-- B) INDICE COMPOSTO
-- Cenário: Relatórios que buscam alunos em uma turma específica com uma situação específica (ex: Aprovados na turma 1).
-- A ordem importa: id_turma primeiro pois é o filtro mais restritivo.
CREATE INDEX idx_aluno_turma_situacao ON aluno_turma(id_turma, situacao);

-- Demonstração de eficácia:
-- EXPLAIN ANALYZE SELECT * FROM aluno_turma WHERE id_turma = 1 AND situacao = 'aprovado';


-- C) INDICE ÚNICO
-- Cenário: Garantir que não existam dois vídeos com a mesma URL na tabela de aulas gravadas.
-- Isso funciona como uma restrição de integridade e índice de performance simultaneamente.
CREATE UNIQUE INDEX idx_aula_url_video ON aula_gravada(url_video);

2. Transações (Integridade dos Dados)
As transações garantem que um conjunto de operações ocorra totalmente ou não ocorra (ACID).

SQL

-- CENÁRIO 1: COMMIT (Sucesso)
-- Objetivo: Transferir um aluno de turma e registrar isso no histórico (simulado) atomicamente.
BEGIN;
    -- 1. Atualiza a turma do aluno para 'trancado' na turma antiga
    UPDATE aluno_turma 
    SET situacao = 'trancado' 
    WHERE id_aluno = 60 AND id_turma = 1;

    -- 2. Insere o aluno na nova turma
    INSERT INTO aluno_turma (id_aluno_turma, id_aluno, id_turma, ano_letivo, situacao) 
    VALUES (999, 60, 2, 2023, 'matriculado'); -- ID 999 simulado

    -- Se não houve erro, confirma ambas as alterações
COMMIT;


-- CENÁRIO 2: ROLLBACK (Erro/Cancelamento)
-- Objetivo: Tentar deletar uma disciplina crítica. Se percebermos o erro, desfazemos.
BEGIN;
    -- Tentativa de deletar matemática
    DELETE FROM disciplina WHERE nome_disciplina = 'Matemática I';
    
    -- Verificamos que isso afetaria muitas outras tabelas ou foi um erro lógico
    -- O comando abaixo desfaz tudo o que foi feito desde o BEGIN
ROLLBACK;


-- CENÁRIO 3: LOCK (Concorrência)
-- Objetivo: Bloquear a linha de uma turma para contagem de vagas, impedindo que outro coordenador edite ao mesmo tempo.
BEGIN;
    -- O 'FOR UPDATE' trava essas linhas específicas até o fim da transação
    SELECT * FROM turma WHERE id_turma = 1 FOR UPDATE;

    -- Realiza atualizações de status...
    UPDATE turma SET status_turma = 'ativa' WHERE id_turma = 1;
COMMIT; -- Libera o travamento

3. Segurança (DCL - Data Control Language)
Criação de papéis com níveis de acesso distintos.

SQL

-- 1. Criação dos Usuários (Roles)
CREATE ROLE u_coordenador WITH LOGIN PASSWORD 'senha_coord_123';
CREATE ROLE u_professor WITH LOGIN PASSWORD 'senha_prof_123';
CREATE ROLE u_aluno WITH LOGIN PASSWORD 'senha_aluno_123';

-- 2. Concessão de Privilégios (GRANT)

-- COORDENADOR: Acesso total às tabelas de estrutura escolar
GRANT ALL PRIVILEGES ON turma, disciplina, curso TO u_coordenador;
GRANT SELECT, INSERT, UPDATE ON usuario, aluno, professor TO u_coordenador;

-- PROFESSOR: Pode ver alunos e turmas, mas só pode INSERIR notas e aulas
GRANT SELECT ON aluno, turma, disciplina TO u_professor;
GRANT INSERT, UPDATE ON nota_prova, nota_trabalho, aula_gravada TO u_professor;

-- ALUNO: Acesso apenas de leitura nas suas notas e aulas (Via Views é mais seguro, mas aqui direto na tabela)
GRANT SELECT ON aula_gravada, horario_aula TO u_aluno;

-- 3. Revogação de Privilégios (REVOKE)
-- Por segurança, removemos a permissão do aluno de ver dados sensíveis de outros usuários
REVOKE ALL ON usuario FROM u_aluno;
-- Bloqueia professor de deletar turmas acidentalmente
REVOKE DELETE ON turma FROM u_professor;

4. Desempenho e Tuning (Otimização)
Otimização da VIEW 3 (Média dos Alunos), que no script original usa Correlated Subqueries (subselects dentro do SELECT para cada linha), o que é pesado para o banco.

Consulta Lenta (Original Conceptual):

SQL

-- A query original executa 4 SELECTs internos para CADA linha de aluno/disciplina.
-- Se houver 1000 alunos e 10 disciplinas, são 40.000 execuções internas.
SELECT 
    u.nome, d.nome_disciplina,
    (SELECT AVG(nota) FROM nota_prova...) + (SELECT AVG(nota) FROM nota_trabalho...) / 2
FROM aluno a ...
Consulta Otimizada (Uso de CTEs e JOINs): Esta versão pré-calcula as médias uma única vez e depois junta os resultados.

SQL

CREATE OR REPLACE VIEW vw_medias_alunos_otimizada AS
WITH media_provas AS (
    -- Calcula média de provas por aluno e disciplina de uma só vez
    SELECT 
        np.id_aluno, 
        po.id_disciplina, 
        AVG(np.nota) as m_prova
    FROM nota_prova np
    JOIN prova_online po ON np.id_prova = po.id_prova
    GROUP BY np.id_aluno, po.id_disciplina
),
media_trabalhos AS (
    -- Calcula média de trabalhos por aluno e disciplina de uma só vez
    SELECT 
        nt.id_aluno, 
        tr.id_disciplina, 
        AVG(nt.nota) as m_trabalho
    FROM nota_trabalho nt
    JOIN trabalho tr ON nt.id_trabalho = tr.id_trabalho
    GROUP BY nt.id_aluno, tr.id_disciplina
)
SELECT 
    u.nome AS aluno,
    d.nome_disciplina,
    -- COALESCE garante que se não houver nota, considera 0
    (COALESCE(mp.m_prova, 0) + COALESCE(mt.m_trabalho, 0)) / 2 AS media_final,
    CASE 
        WHEN ((COALESCE(mp.m_prova, 0) + COALESCE(mt.m_trabalho, 0)) / 2) < 6 THEN 'Abaixo da Média'
        ELSE 'OK'
    END AS situacao
FROM aluno a
JOIN usuario u ON a.id_aluno = u.id_usuario
JOIN aluno_turma atur ON a.id_aluno = atur.id_aluno
JOIN turma t ON atur.id_turma = t.id_turma
JOIN disciplina d ON t.id_turma = d.id_turma
-- LEFT JOIN garante que traga o aluno mesmo se ele não tiver notas ainda
LEFT JOIN media_provas mp ON a.id_aluno = mp.id_aluno AND d.id_disciplina = mp.id_disciplina
LEFT JOIN media_trabalhos mt ON a.id_aluno = mt.id_aluno AND d.id_disciplina = mt.id_disciplina;
Comparativo de Tuning:

Original: Complexidade O(N*M) - Executa subqueries repetidamente.

Otimizada: Complexidade O(N) - Agrega primeiro, depois faz o match. Em grandes volumes de dados, essa versão será drasticamente mais rápida.
